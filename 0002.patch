From 40e991896d872ffc098405460c3315334d328f28 Mon Sep 17 00:00:00 2001
From: Raja Appuswamy <raja.appuswamy@epfl.ch>
Date: Sat, 4 Jul 2015 13:19:14 +0000
Subject: [PATCH] Update cache replacement policy to resolve priority ties
 based on subplans, fix compilation error, and chunk naming
 related fixes

---
 postgresql-9.2.1/src/backend/executor/nodeHash.c   |   39 -------------------
 .../src/backend/executor/nodeMultiJoin.c           |   15 +++++++-
 postgresql-9.2.1/src/backend/smooth/joincache.c    |   40 +++++++++++++++-----
 postgresql-9.2.1/src/include/smooth/joincache.h    |    2 +-
 4 files changed, 45 insertions(+), 51 deletions(-)

diff --git a/postgresql-9.2.1/src/backend/executor/nodeHash.c b/postgresql-9.2.1/src/backend/executor/nodeHash.c
index 19d377e..c783bfc 100755
--- a/postgresql-9.2.1/src/backend/executor/nodeHash.c
+++ b/postgresql-9.2.1/src/backend/executor/nodeHash.c
@@ -2981,45 +2981,6 @@ HashInfo * add_hashinfo(MultiHashState *mhstate , List * clauses, List *hoperato
 
 }
 
-void ExecResetMultiHashtable(MultiHashState *node, SimpleHashTable  * hashtables){
-
-	ListCell *lc;
-	List *hashkeys;
-	SimpleHashTable hashtable;
-	MemoryContext oldcxt;
-
-
-
-	// Reset the all the buckets:
-
-
-
-	foreach(lc,node->all_hashkeys) {
-
-
-		HashInfo * hinfo = (HashInfo *) lfirst(lc);
-
-		hashtable = hashtables[hinfo->id];
-
-		MemoryContextReset(hashtable->hashCxt);
-
-
-
-		// Update hashtable info
-		hashtable->totalTuples = 0;
-		hashtable->spaceAllowed += hashtable->spaceUsed;
-
-
-		/* Allocate data that will live for the life of the multihashjoin */
-		ExecMultiHashAllocateHashtable(hashtable);
-
-
-
-	}
-
-
-}
-
 static void ExecMultiHashAllocateHashtable(SimpleHashTable hashtable) {
 
 	int i;
diff --git a/postgresql-9.2.1/src/backend/executor/nodeMultiJoin.c b/postgresql-9.2.1/src/backend/executor/nodeMultiJoin.c
index 49a2e5a..dea5009 100644
--- a/postgresql-9.2.1/src/backend/executor/nodeMultiJoin.c
+++ b/postgresql-9.2.1/src/backend/executor/nodeMultiJoin.c
@@ -1166,7 +1166,7 @@ static void ExecInitJoinCache(MultiJoinState * mhjoinstate) {
 	int chunksLeft = chunks_per_cycle;
 	while (chunksLeft) {
 
-		RelChunk * chunk =  JC_processNextChunk(true);
+		RelChunk * chunk =  JC_processNextChunk();
 		MultiHashState *mhstate = mhjoinstate->mhashnodes[ChunkGetRelid(chunk)];
 		JC_InitChunkMemoryContext(chunk, NULL);
 		ExecPrepareChunk(mhjoinstate, mhstate, chunk);
@@ -1371,7 +1371,7 @@ static List * ExecMultiJoinPrepareSubplans(MultiJoinState * mhjoinstate, int ski
 
 static RelChunk * ExecMultiJoinChooseDroppedChunk(MultiJoinState * mhjoinstate, RelChunk *newChunk) {
 
-	int i;
+	int i, pri;
 	List *result = NIL;
 	RelChunk **chunk_array;
 	RelChunk *toDrop = NULL;
@@ -1501,9 +1501,11 @@ static RelChunk * ExecMultiJoinChooseDroppedChunk(MultiJoinState * mhjoinstate,
 
 
 			toDrop = ExecSortChuks(chunk_array, list_length(chunks));
+			pri = toDrop->priority;
 
 			// Don't delete! Implementation for choosing a lowet priority chunk
 			// from the same relation as the new chunk
+
 			bool done = false ;
 			foreach( lc,chunks) {
 
@@ -1514,6 +1516,7 @@ static RelChunk * ExecMultiJoinChooseDroppedChunk(MultiJoinState * mhjoinstate,
 						chunk->priority);
 				fflush(stdout);
 
+#if 0
 				if (!done 
 					&& ChunkGetRelid(toDrop) != ChunkGetRelid(newChunk)
 					&& chunk->priority== toDrop->priority
@@ -1522,9 +1525,17 @@ static RelChunk * ExecMultiJoinChooseDroppedChunk(MultiJoinState * mhjoinstate,
 					toDrop = chunk;
 					done = true ;
 				}
+#endif
+				if (chunk->priority == pri &&
+				    (list_length(chunk->subplans) <
+				    list_length(toDrop->subplans))) {
+				    toDrop = chunk;
+				}
+
 				chunk->priority = 0;
 
 			}
+
 			//pfree(chunk_array);
 		}
 			break;
diff --git a/postgresql-9.2.1/src/backend/smooth/joincache.c b/postgresql-9.2.1/src/backend/smooth/joincache.c
index 2613f8e..30ef442 100644
--- a/postgresql-9.2.1/src/backend/smooth/joincache.c
+++ b/postgresql-9.2.1/src/backend/smooth/joincache.c
@@ -145,9 +145,10 @@ void JC_AddChunkedSubPlan(ChunkedSubPlan *subplan) {
 int JC_swiftNextChunk(RelChunk **result)
 {
     jbuilder_t *builder;
-    char buf[128], *json_data, *fname, *rel_name;
-    ListCell *cell, *elem, *prev;
-    RelChunk *chunk;
+    char cbuf[128], obuf[128], *json_data, *fname, *rel_name;
+    ListCell *cell, *elem, *prev, *cached_cell;
+    RelChunk *chunk, *cchunk;
+    bool is_cached;
     uint32 rel_id, index, chunk_id;
 	List *clist = NIL;
 
@@ -177,6 +178,21 @@ int JC_swiftNextChunk(RelChunk **result)
 	    foreach(cell, seq_cycle) {
 		    chunk = (RelChunk *) lfirst(cell);
 
+		    // if chunk is cached, continue to next chunk
+            is_cached = false;
+            foreach(cached_cell, JCacheSegHdr->chunks) {
+                cchunk = (RelChunk *) lfirst(cached_cell);
+
+                if (cchunk->rel_id == chunk->rel_id && 
+                    (cchunk->chunkID & 0xFFFF) == (chunk->chunkID & 0xFFFF)) {
+                    is_cached = true;
+                    break;
+                }
+            }
+
+            if (is_cached)
+                continue;
+
             // find relevant container
             ctarget = NULL;
 	        foreach(elem, clist) {
@@ -188,14 +204,14 @@ int JC_swiftNextChunk(RelChunk **result)
                 }
             }
 
+            snprintf(cbuf, sizeof(cbuf), "%d", chunk->rel_id);
+
             // if container is not found, we have to create one
             if (!ctarget) {
                 ctarget = calloc(1, sizeof(struct container_wrapper));
                 Assert(ctarget);
 
-                snprintf(buf, sizeof(buf), "%d", chunk->rel_id);
-
-                ctarget->c = jbuilder_create_container(builder, buf);
+                ctarget->c = jbuilder_create_container(builder, cbuf);
                 ctarget->rel_id = chunk->rel_id;
 
 			    clist = lappend(clist, ctarget);
@@ -204,8 +220,14 @@ int JC_swiftNextChunk(RelChunk **result)
             Assert(ctarget);
 
             // now add the chunk itself to the container
-            snprintf(buf, sizeof(buf), "%d", chunk->chunkID & 0xFFFF);
-            jbuilder_add_object(builder, ctarget->c, buf);
+            if ((chunk->chunkID & 0xFFFF) == 0) {
+                snprintf(obuf, sizeof(obuf), "%s", cbuf);
+            } else {
+                snprintf(obuf, sizeof(obuf), "%s.%d", cbuf, 
+                    chunk->chunkID & 0xFFFF);
+            }
+
+            jbuilder_add_object(builder, ctarget->c, obuf);
             nchunks_requested++;
 
             printf("Adding chunk %u to cont %u\n", chunk->chunkID & 0xFFFF,
@@ -266,7 +288,7 @@ int JC_swiftNextChunk(RelChunk **result)
     return index;
 }
 
-RelChunk * JC_processNextChunk(bool poll_swift) {
+RelChunk * JC_processNextChunk() {
 
 
 //	JoinCacheEntry *jcentry;
diff --git a/postgresql-9.2.1/src/include/smooth/joincache.h b/postgresql-9.2.1/src/include/smooth/joincache.h
index 3dd01d2..854bcd8 100644
--- a/postgresql-9.2.1/src/include/smooth/joincache.h
+++ b/postgresql-9.2.1/src/include/smooth/joincache.h
@@ -127,7 +127,7 @@ extern MinimalTuple JC_StoreMinmalTuple(RelChunk *chunk , MinimalTuple mtuple);
 
 extern void JC_InitChunk(uint32 size, Relation relation, Index index);
 extern void JC_ResetChunk(Relation relation, Index index);
-extern RelChunk * JC_processNextChunk(bool poll_swift);
+extern RelChunk * JC_processNextChunk();
 extern void make_random_seq(RelOptInfo ** rel_array, int size) ;
 extern void JC_DeleteChunk(RelChunk *chunk);
 #endif /* JOINCACHE_H_ */
-- 
1.7.9.5

